# ESLint新規ルール設定レビュープロセス

このドキュメントは、ESLintプラグインの更新により新規追加されたルールを評価し、既存コードベースに適した設定を決定するプロセスを定義します。

## プロセスの概要

### 目的

- **品質保証**: 新規ルールを既存コードベースの品質基準と整合させる
- **効率性**: 段階的かつ体系的なレビューで判断コストを最小化
- **透明性**: 設定判断の根拠を明確に記録し、将来の変更や議論に活用
- **再利用性**: 次回の依存関係更新時に同様のプロセスを再現可能にする

### 適用シーン

- ESLintプラグインのメジャー/マイナーバージョンアップ
- 新しいESLintプラグインの導入
- 既存ルール設定の大規模な見直し

### 成果物

1. **新規ルール一覧** (`new-rules-v{version}.md`)
   - 人間可読形式の新規ルールリスト
   - プラグインごとに整理されたテーブル形式
   - ドキュメントリンク付き

2. **詳細分析YAML** (`rules-review-v{version}.yaml`)
   - 機械可読形式の詳細分析
   - 各ルールの推奨設定、理由、影響度、自動修正可否
   - 将来的な自動化や統計分析に活用可能

3. **判断サマリー** (`rules-review-summary-v{version}.md`)
   - エグゼクティブサマリー（総ルール数、有効化/off/判断要の内訳）
   - 即座に有効化推奨ルール一覧
   - 継続off推奨ルール一覧
   - 判断要検討ルールの詳細分析
   - 設定変更の具体的手順

4. **設定ファイルの更新**
   - `src/configs/{plugin}.ts`の更新
   - 新規ルールを適切に設定に反映

---

## 詳細な手順

### フェーズ1: 新規ルールの抽出と一覧化

#### 作業内容

1. **依存関係の更新**

   ```bash
   pnpm update
   ```

2. **新規ルールの特定**
   - ESLint実行時のwarningメッセージから新規ルールを特定
   - または、各プラグインのCHANGELOG/リリースノートを確認

3. **一覧ドキュメントの作成**
   - ファイル名: `docs/new-rules-v{version}.md`
   - プラグインごとにセクション分け
   - テーブル形式でルール名、説明、ドキュメントリンクを記載

#### テンプレート

```markdown
# 新規追加ルール一覧 (v{version})

依存関係の更新により、各プラグインで新しいルールが追加されました。
これらのルールは現在すべて `"off"` に設定されています。

## 目次

- [eslint-plugin-{name}](#eslint-plugin-{name})
  ...

---

## eslint-plugin-{name}

**バージョン**: {version}

### 新規追加ルール

| ルール名          | 説明   | ドキュメント  |
| ----------------- | ------ | ------------- |
| `{plugin}/{rule}` | {説明} | [docs]({url}) |

...
```

#### 品質チェックポイント

- [ ] すべての新規ルールが漏れなくリストアップされている
- [ ] ドキュメントリンクが正しく機能する
- [ ] プラグインのバージョン番号が正確
- [ ] 非推奨となったルールも記載されている（削除された場合）

---

### フェーズ2: コードベース特性の分析

#### 作業内容

既存のコードベースの特徴を明確化し、ルール評価の基準を定義します。

1. **既存設定ファイルの確認**

   ```bash
   ls src/configs/*.ts
   ```

2. **既存ルール設定パターンの分析**
   - プラグインごとの設定ポリシー（error/warn/off の使い分け）
   - 既存のオーバーライド設定
   - コメントに記載された設定理由

3. **コードベース特性の文書化**
   - TypeScript使用の有無
   - ES Modules/CommonJSの使用状況
   - JSDocの使用方針
   - テストフレームワーク（Jest/Vitest等）
   - ブラウザ/Node.js環境

#### 分析観点

```yaml
codebase_characteristics:
  - "TypeScript優先（any型禁止）"
  - "ES Modules使用"
  - "トップレベルawait不使用"
  - "null/undefinedは `== null` でチェック"
  - "JSDocは最小限（TypeScript型定義優先）"
  - "配列メソッド（reverse/sort）は必要に応じて使用"
```

#### 品質チェックポイント

- [ ] 既存設定ファイルをすべて確認した
- [ ] コーディング規約や開発ガイドラインを参照した
- [ ] 実際のソースコードのパターンをサンプリング確認した

---

### フェーズ3: ルールごとの詳細分析

#### 作業内容

各ルールを個別に評価し、推奨設定を決定します。

#### 使用するツール・手法

1. **ルールドキュメントの確認**
   - 各ルールの公式ドキュメントを読む
   - 目的、検出パターン、自動修正可否を確認

2. **既存コードとの整合性チェック**
   - 既存コードで同様のパターンがあるか検索

   ```bash
   # 例: Array#reverse()の使用状況確認
   grep -r "\.reverse()" src/
   ```

3. **影響度の評価**
   - **high**: バグパターンの検出、既存コードに大きな変更が必要
   - **medium**: コードスタイルの統一、部分的な修正が必要
   - **low**: 新規コードのみ影響、自動修正可能

#### 判断基準

各ルールを以下の基準で評価します：

| 基準                         | 評価内容                                                       |
| ---------------------------- | -------------------------------------------------------------- |
| **既存ポリシーとの整合性**   | 既存の設定ポリシーに合致するか                                 |
| **実用性**                   | false positiveが少なく、実際のバグ検出に有効か                 |
| **影響範囲**                 | 既存コードへの影響度（修正箇所数、破壊的変更の有無）           |
| **自動修正可能性**           | 自動修正できるか（できる場合は優先的に有効化検討）             |
| **コードベース特性との整合** | TypeScript/JSDoc、ES Modules/CommonJS等の使用状況と整合するか  |
| **成熟度**                   | 実験的機能か、安定版か                                         |
| **設定の柔軟性**             | オプションで調整可能か、特定のファイルパターンで無効化が必要か |

#### 推奨設定の分類

1. **error**: 即座に有効化推奨
   - 明確なバグパターンを検出
   - 既存コードベースと整合
   - false positiveが少ない

2. **warn**: 警告レベルで有効化
   - 有用だが、可読性等とのトレードオフがある
   - 段階的な適用を推奨

3. **off**: 継続して無効化
   - 既存ポリシーと不整合
   - 制限が厳しすぎる
   - 実験的機能で安定していない

4. **decision_required**: ユーザー判断が必要
   - プロジェクト固有の判断が必要
   - 複数の妥当な選択肢がある

#### YAML構造

```yaml
plugins:
  { plugin-name }:
    version: "{version}"
    existing_policy: "{既存のポリシー説明}"
    rules:
      - name: "{plugin}/{rule-name}"
        current: "off"
        recommended: "error" # または "warn", "off"
        reason: "{推奨設定の理由}"
        fixable: true # または false
        impact: "low" # または "medium", "high"
        decision_required: true # 判断が必要な場合のみ
        decision_criteria: "{判断基準}" # decision_required時のみ
        configuration_note: | # 特別な設定が必要な場合
          {設定例}
        already_configured: true # 既存ポリシーで既設定の場合
```

#### 品質チェックポイント

- [ ] すべてのルールに推奨設定と理由が記載されている
- [ ] 自動修正可否が正確に記録されている
- [ ] 影響度の評価が適切（実際の既存コードを確認）
- [ ] 判断要検討ルールには判断基準が明記されている

---

### フェーズ4: サマリードキュメントの作成

#### 作業内容

YAMLファイルの内容を人間が読みやすい形式でまとめます。

#### テンプレート構造

```markdown
# ESLint v{version} 新規ルール設定レビューサマリー

**分析日**: YYYY-MM-DD

## エグゼクティブサマリー

- **総ルール数**: {total}個
- **即座に有効化推奨**: **{enable}個**
- **継続off推奨**: **{off}個**（{already_configured}個は既存ポリシーに従い既設定済み）
- **判断要検討**: **{decision}個**

## 📊 推奨設定概要

| プラグイン | 総ルール数 | 有効化推奨 | off推奨 | 判断要 |
| ---------- | ---------- | ---------- | ------- | ------ |
| ...        | ...        | ...        | ...     | ...    |

## ✅ 即座に有効化推奨（{enable}個）

{プラグインごとにテーブル形式で列挙}
{設定注意事項があれば追記}

## 🚫 継続off推奨（{off}個）

### 既存ポリシーにより既設定済み（{already_configured}個）

{プラグインごとにポリシーと概要を記載}

### 新規off推奨（{new_off}個）

{テーブル形式で列挙}

## 🤔 判断要検討（{decision}個）

{各ルールごとに詳細な分析}

- 判断軸
- 説明
- 背景
- 推奨アクション（設定例を含む）

## 🔧 設定変更の手順

### ステップ1: 有効化推奨ルールの適用

{具体的なコード例}

### ステップ2: 既存コードのチェック

{実行コマンド}

### ステップ3: 判断要検討ルールの決定

{チーム議論のポイント}

## 📝 変更影響の見積もり

- 自動修正可能性
- 破壊的変更の可能性
- false positiveリスク
- 推奨タイミング

## 🎯 次のアクション

- [ ] 有効化推奨ルールを設定ファイルに反映
- [ ] `pnpm lint`で既存コードへの影響を確認
- [ ] 自動修正可能なルールは`pnpm lint:fix`で修正
- [ ] 判断要検討ルールについてチームで議論
- [ ] コミット
```

#### 品質チェックポイント

- [ ] 統計情報が正確（YAMLファイルと一致）
- [ ] すべてのセクションが記載されている
- [ ] 具体的なアクションステップが明確
- [ ] コード例が正しく動作する

---

### フェーズ5: 設定ファイルの更新

#### 作業内容

推奨設定を実際の設定ファイルに反映します。

#### 手順

1. **有効化推奨ルールの反映**

   ```typescript
   // src/configs/{plugin}.ts

   // 新規ルールを追加（YAMLの推奨設定に従う）
   "{plugin}/{rule}": "error",
   "{plugin}/{rule2}": "warn",
   "{plugin}/{rule3}": "off",
   ```

2. **オーバーライド設定の追加（必要に応じて）**

   ```typescript
   // eslint.config.js または該当する設定ファイル

   {
     files: ["scripts/**/*.ts"],
     rules: {
       "node/no-top-level-await": "off"
     }
   }
   ```

3. **設定の検証**

   ```bash
   # Lintエラーがないことを確認
   pnpm lint

   # 自動修正可能なものを修正
   pnpm lint:fix
   ```

4. **テストの実行**
   ```bash
   # すべてのテストが通ることを確認
   pnpm test
   ```

#### 品質チェックポイント

- [ ] すべての有効化推奨ルールが反映されている
- [ ] 必要なオーバーライド設定が追加されている
- [ ] Lintエラーが解消されている
- [ ] テストが通る
- [ ] 設定ファイルのフォーマットが統一されている

---

### フェーズ6: ユーザーフィードバック統合

#### 作業内容

判断要検討ルールについて、ユーザーまたはチームと議論し、最終決定を行います。

#### 手法

1. **議論のポイントを整理**
   - サマリードキュメントの「判断要検討」セクションを共有
   - 判断軸と選択肢を明確に提示

2. **フィードバックの収集**
   - Pull Request/Issueでのコメント
   - チームミーティングでの議論
   - 投票やアンケート

3. **決定の記録**
   - 決定内容と理由をYAMLファイルに追記

   ```yaml
   - name: "{plugin}/{rule}"
     # ... 既存の内容
     final_decision: "error" # または "off"
     decision_date: "YYYY-MM-DD"
     decision_rationale: "{決定理由}"
   ```

4. **設定の更新**
   - 決定に基づいて設定ファイルを更新
   - 再度Lint/テストを実行

#### 品質チェックポイント

- [ ] すべての判断要検討ルールについて決定がなされた
- [ ] 決定理由が明確に記録されている
- [ ] チーム内で合意が得られている

---

## テンプレートとベストプラクティス

### YAMLファイルのベストプラクティス

1. **一貫性の維持**
   - すべてのルールに同じ構造を使用
   - 必須フィールド: `name`, `current`, `recommended`, `reason`, `fixable`, `impact`

2. **理由の明確化**
   - 「WHY」を説明する（実装詳細のWHATではなく）
   - 既存コードベースの特性との関連を明示
   - トレードオフがある場合は両面を記載

3. **設定例の提供**
   - 特別な設定が必要な場合は`configuration_note`に記載
   - コピペで使える形式で記述

### Markdownファイルのベストプラクティス

1. **読みやすさ優先**
   - テーブル形式を活用
   - 絵文字で視覚的に分類（✅ 有効化、🚫 off、🤔 判断要）
   - セクション構造を明確に

2. **アクション指向**
   - 具体的な次のステップを明示
   - チェックリスト形式で進捗管理しやすく

3. **クロスリファレンス**
   - YAMLファイルへのリンク
   - 新規ルール一覧へのリンク
   - 既存の設定ファイルへのリンク

### ルール評価の観点（チェックリスト）

各ルールを評価する際、以下の質問に答えます：

- [ ] このルールは何を検出するか？（目的）
- [ ] 既存コードで同様のパターンを使用しているか？
- [ ] 既存の設定ポリシーと整合するか？
- [ ] false positiveのリスクはあるか？
- [ ] 自動修正できるか？
- [ ] 影響範囲はどの程度か？（修正箇所数の見積もり）
- [ ] 特定の環境でのみ有効か？（オーバーライドが必要か）
- [ ] トレードオフは何か？（可読性、パフォーマンス等）
- [ ] 実験的機能か、安定版か？

### 自動化できる部分

以下の部分は将来的にスクリプト化可能です：

1. **新規ルールの抽出**
   - ESLint APIを使用してルール一覧を取得
   - 既存設定との差分を抽出

2. **テンプレート生成**
   - YAMLファイルのスケルトン生成
   - Markdownファイルの目次とセクション生成

3. **統計情報の計算**
   - YAMLファイルから総ルール数、内訳を自動計算
   - サマリーテーブルの自動生成

4. **設定ファイルの生成**
   - YAMLファイルから設定コードを生成

```typescript
// 自動化スクリプトの例（将来的な実装）
// scripts/generate-rules-review.ts

import { existingConfig } from "../src/configs";
import { getAllRules } from "./utils/eslint-api";

const existingRules = extractRulesFromConfig(existingConfig);
const allRules = await getAllRules();
const newRules = allRules.filter((rule) => !existingRules.includes(rule));

// YAMLテンプレート生成
generateYAMLTemplate(newRules);

// Markdownテンプレート生成
generateMarkdownTemplate(newRules);
```

---

## 今回の実績（v7.2.0）

### 処理したルール数

- **総ルール数**: 78個
- **即座に有効化推奨**: 15個（19%）
- **継続off推奨**: 62個（79%）
  - うち既存ポリシーで既設定済み: 59個
  - うち新規off推奨: 3個
- **判断要検討**: 1個（1%）

### プラグイン別内訳

| プラグイン                | 総ルール数 | 有効化 | off | 判断要 |
| ------------------------- | ---------- | ------ | --- | ------ |
| eslint-plugin-unicorn     | 18         | 12     | 6   | 0      |
| eslint-plugin-jest        | 1          | 0      | 1   | 0      |
| eslint-plugin-jsdoc       | 13         | 0      | 13  | 0      |
| @eslint/markdown          | 20         | 0      | 20  | 0      |
| eslint-plugin-n           | 1          | 1      | 0   | 0      |
| eslint-plugin-react-hooks | 24         | 0      | 24  | 0      |
| eslint-plugin-import-x    | 1          | 0      | 0   | 1      |

### 判断が改められたケースと学び

**ケース1: トレードオフのあるルールは段階的アプローチ**

- **ルール**: `unicorn/prefer-single-call`
- **初期判断**: off（制限が厳しすぎる）
- **改定理由**: ユーザーから「warnにしてみて」との提案
- **学び**: 有用だが可読性とのトレードオフがあるルールは、一律offにせず`warn`レベルから開始することで、段階的に効果を検証できる

**ケース2: 環境依存性の高いルールはオーバーライド設定例を提示**

- **ルール**: `node/no-top-level-await`、`unicorn/require-module-specifiers`、`unicorn/prefer-import-meta-properties`
- **初期判断**: 単純なon/off判断
- **改定理由**: ユーザーから環境ごとの使い分けの必要性が指摘された
  - トップレベルawait: スクリプトでは使う、ライブラリでは禁止
  - モジュール拡張子: Node.js ESMでは必須、ブラウザビルドやCJSでは不要
  - import.meta: ESMでは推奨、CommonJSでは使えない
- **学び**: ESM/CommonJS、Browser/Node.js、スクリプト/ライブラリなど、コードの実行環境・用途によって要求が異なるルールは、オーバーライド設定例を複数パターン提示することで、ユーザーが適切に調整できる

**ケース3: 理由付けの正確性が重要**

- **ルール**: `unicorn/require-module-specifiers`
- **初期判断理由**: 「TypeScript環境では拡張子不要。bundlerとの互換性問題の可能性」
- **ユーザー指摘**: 「これは誤った理由を挙げている。ESMであるならば常に拡張子が必須」
- **改定理由**: 「ESM環境では拡張子が必須。Node.jsでTypeScript直接実行する場合も.ts拡張子が必須となる」
- **学び**: 判断理由が不正確だと、将来の議論や設定変更時に混乱を招く。技術的に正確な理由付けを心がける必要がある

**ケース4: 段階的なフィードバックによる精緻化**

- **ルール**: `unicorn/prefer-bigint-literals`
- **初期判断**: decision_required（判断要検討）
- **改定理由**: ユーザーフィードバックで一度保留判断が出た後、再考により有効化に決定
- **学び**: ユーザー自身も段階的に考えを整理する。即断を求めず、議論の余地を残すことが重要

### 所要時間

- フェーズ1（新規ルール抽出）: 約30分
- フェーズ2（コードベース分析）: 約15分
- フェーズ3（ルール詳細分析）: 約2時間（78ルール）
- フェーズ4（サマリー作成）: 約45分
- フェーズ5（設定ファイル更新）: 約15分
- フェーズ6（レビューと修正）: 約30分

**合計**: 約4時間15分

### 学んだ教訓

1. **既存ポリシーの明確化が重要**
   - 事前にコードベース特性を文書化することで、評価が一貫する
   - プラグインごとの設定方針を明示的に記録すべき

2. **判断軸の明示化**
   - 単に「off」「error」を示すだけでなく、「なぜそう判断したか」を記録
   - 将来の議論や変更時に役立つ
   - 誤った理由付けはユーザーから指摘される（require-module-specifiersの事例）

3. **自動修正可否の影響**
   - 自動修正可能なルールは有効化のハードルが低い
   - この情報を早期に確認することで優先順位付けが容易

4. **トレードオフの明示**
   - 可読性とのトレードオフがあるルールは`warn`レベルから開始
   - 一律「error」にせず、段階的アプローチが有効

5. **環境ごとのオーバーライド設定の必要性**
   - ESM/CommonJS、Browser/Node.js、スクリプト/ライブラリコードなど環境で要求が異なる
   - オーバーライド設定例を提示することで、ユーザーが適切に調整できる
   - `node/no-top-level-await`、`unicorn/require-module-specifiers`、`unicorn/prefer-import-meta-properties`で実践

6. **ユーザーフィードバックループの価値**
   - 初期提案からフィードバックを受けて5個のルールが調整された
   - 段階的な議論により、より適切な設定に到達できた

---

## 次回の改善ポイント

1. **スクリプト化**
   - 新規ルール抽出の自動化
   - YAMLテンプレート生成の自動化
   - 統計情報の自動計算

2. **テンプレートの改善**
   - より詳細な評価基準チェックリスト
   - プラグインごとの評価テンプレート

3. **ドキュメント構造**
   - ADR（Architecture Decision Records）形式での記録も検討
   - 変更履歴の追跡を容易にする

4. **フィードバックループ**
   - 有効化したルールの効果測定
   - false positive/negativeの記録と改善
